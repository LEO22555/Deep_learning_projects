# -*- coding: utf-8 -*-
"""object-detection-i_abf47929-6254-4c3c-94ee-7b6fba12deb2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sOIuu1jeaFFjuUVAStlled3Pt4r7EmBs

# 1. Generando un sliding window
"""

!pip install opencv-python-headless==4.1.2.30

import cv2
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import os

np_image = cv2.imread('pexels-frank-cone.jpg')
np_image = cv2.cvtColor(np_image, cv2.COLOR_BGR2RGB)
np_image = cv2.resize(np_image, dsize=(1000, 1000))
plt.imshow(np_image)

def sliding_window(image, step, ws):
  for y in range(0, image.shape[0]-ws[1]+1, step):
    for x in range(0, image.shape[1]-ws[0]+1, step):
      yield (x, y, image[y:y + ws[1], x:x +ws[0]])

windows = sliding_window(np_image, 200, (200, 200))

os.makedirs('sliding_window')

for x, window in enumerate(windows):
  f, axarr = plt.subplots(1, 2, figsize=(12, 12))
  axarr[0].imshow(np_image)
  rect = patches.Rectangle((window[0], window[1]), 200, 200, linewidth=2, edgecolor='g', facecolor='none')
  axarr[0].add_patch(rect)
  axarr[1].imshow(window[2])
  f.savefig('sliding_window/'+str(x)+'.png', dpi=f.dpi)

image_folder = 'sliding_window'
video_name = 'video.avi'

images = [img for img in os.listdir(image_folder) if img.endswith('.png')]

images = sorted(images, key=lambda x: int(os.path.splitext(x)[0]))

frame = cv2.imread(os.path.join(image_folder, images[0]))

height, width, layer = frame.shape

video = cv2.VideoWriter(video_name, 0, 1, (width, height))

for image in images:
  video.write(cv2.imread(os.path.join(image_folder, image)))
video.release()

"""# Trabajando con m√©tricas de object detection"""

import numpy as np

def bb_intersection_over_union(ground_truth_bbox, predicted_bbox):
  xA = max(ground_truth_bbox[0], predicted_bbox[0])
  yA = max(ground_truth_bbox[1], predicted_bbox[1])
  xB = min(ground_truth_bbox[2], predicted_bbox[2])
  yB = min(ground_truth_bbox[3], predicted_bbox[3])

  intersection_area = max(0, xB-xA + 1) * max(0, yB-yA + 1)

  ground_truth_bbox_area = (ground_truth_bbox[2] - ground_truth_bbox[0] + 1) * (ground_truth_bbox[3] - ground_truth_bbox[1] + 1)
  predicted_bbox_area = (predicted_bbox[2] - predicted_bbox[0] + 1) * (predicted_bbox[3] - predicted_bbox[1] + 1)

  iou = intersection_area / float(ground_truth_bbox_area + predicted_bbox_area - intersection_area)

  return iou

image = cv2.imread('pexels-frank-cone.jpg')
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

example = ([1400, 850, 1650, 1100], [1400, 850, 1600, 1100])

iou = bb_intersection_over_union(example[0], example[1])

print('Valor IoU ' + str(iou))

fig, ax = plt.subplots(figsize=(15, 15))

ax.imshow(image)
rect = patches.Rectangle(tuple(example[0][:2]), example[0][2]-example[0][0], example[0][3]-example[0][1], linewidth=3, edgecolor='g', facecolor='none')
ax.add_patch(rect)

rect = patches.Rectangle(tuple(example[1][:2]), example[1][2]-example[1][0], example[1][3]-example[1][1], linewidth=3, edgecolor='r', facecolor='none')
ax.add_patch(rect)

plt.show()